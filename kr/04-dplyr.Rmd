---
layout: topic
title: dplyr로 데이터 집계와 분석
author: Data Carpentry contributors
---

```{r, echo=FALSE, purl=FALSE, message = FALSE}
#source("setup.R")
surveys <- read.csv("data/portal_data_joined.csv")
```

------------

> ## 학습목표
>
> 이번 학습단원을 마치게 되면, 학습자는 다음 작업을 수행할 수 있는 경험치를 얻게 된다.:
>
> * `dplyr` 팩키지에 사용되는 데이터 조작에 사용되는 '동사(verbs)' 6개를 익히게 된다.
> * 데이터프레임에서 열 부분집합을 선택하게 되고 조건에 맞는 행을 필터링한다.
> * `파이프(pipe)` 연산자를 사용해서 `dplyr` 동사를 순열로 조합하여 연결시킬 수 있다.
> * `mutate` 명령어를 사용해서 함수를 기존 열에 적용해서 신규 칼럼을 생성할 수 있다.
> * `write.csv` 함수를 사용해서 데이터프레임을 `.csv` 파일로 내보내는 방법을 익힌다.

------------

# `dplyr` 팩키지를 활용한 데이터 조작

꺽쇠 연산자를 활용한 부분집합 뽑아내는 방법은 편리하기도 하지만,
복잡한 연산작업에는 가독성이 떨어진다.
`dplyr` 세상속으로 들어가 보자.
`dplyr`은 데이터조작을 더 쉽고 데이터 분석을 즐겁도록 개발된 팩키지다.

R에서 팩키지 역할은 더 많은 작업을 수행할 수 있도록 함수를 모아놓은 것이다.
지금까지 사용한 함수, 예를 들면, `str()` 혹은 `data.frame()`은 
R에 기본으로 내장된 것이다; 처음 팩키지를 사용하려면, 본인 컴퓨터에 팩키지를 
설치해야 된다. 그리고 나서 필요할 때마다 R 세션에서 가져와서 사용해야 된다.

```{r, eval = FALSE, purl = FALSE}
install.packages("dplyr")
```

CRAN 미러(mirror)를 지정하도록 요청받는 경우가 있다 --
본질적으로 팩키지를 다운로드 받을 웹사이트를 지정하는 것과 다름없다.
어떤 것을 고르든지 그다지 차이가 나지 않는다; 굳이 선택하라고 하면
RStudio 미러를 추천한다.

```{r, message = FALSE, purl = FALSE}
library("dplyr")    ## 팩키지 적재
```

## `dplyr`은 뭘까?

`dplyr` 팩키지에는 흔히 데이터를 조작하는데 필요한 쉬운 도구가 포함되어 있다.
`dplyr` 팩키지는 데이터프레임과 직접붙어 동작하도록 개발되었다.
`dplyr` 팩키지 이면에는 그전에 한동안 폭넓게 사용된 `plyr` 팩키지에서 영감을 받았는데,
`plyr` 팩키지는 일부 경우에 속도가 떨어지는 성능문제가 있었다.
`dplyr`은 연산 상당부분을 C++로 이식해서 이 문제를 해결했다.
추가적인 기능으로 외부 데이터베이스에 저장된 데이터와 직접 붙어 작업할 수도 있다.
이런 방식으로 작업을 수행하게 되면 데이터는 자연스럽게 관계형 데이터베이스에서 관리되어
질의문은 데이터베이스 위에서 실행되고, 질의문 실행결과만 반환된다.

이런 접근법은 R에서 흔히 접하게 되는 일반적인 메모리 관련된 문제에 대한 해법이 된다.
일반적으로 R에서 작업할 수 있는 데이터 크기는 가용한 메모리 크기로 제약된다.
데이터베이스 연결이 체결되면 이러한 R 한계를 극복하게 되어 수백 GB 크기를 갖는 데이터를 
데이터베이스에 넣고, 직접 질의문을 던져 분석에 필요한 데이터를 R로 끌어올 수 있다.

워크샵을 마치고 나서 `dplyr`에 대해 더 많이 배우고자 하는 경우, 
[dplyr cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)를 참조한다.



## 칼럼을 뽑아내고 행을 필터링한다.

`dplyr` 함수중에서 가장 활용도가 높은 함수를 학습한다: `select()`,
`filter()`, `mutate()`, `group_by()`, `summarize()`. 
데이터프레임에서 칼럼을 뽑아낼 때 `select()`를 사용한다. 
`select()` 함수에 넣은 첫번째 인자는 데이터프레임(`surveys`), 그리고 
후속 인자는 뽑아낼 칼럼이 인자로 들어간다.

```{r, results = 'hide', purl = FALSE}
select(surveys, plot_id, species_id, weight)
```

행을 뽑아내는데 `filter()`를 사용한다:

```{r, purl = FALSE}
filter(surveys, year == 1995)
```

## 파이프(Pipes)



But what if you wanted to select and filter at the same time? There are three
ways to do this: use intermediate steps, nested functions, or pipes. With the
intermediate steps, you essentially create a temporary data frame and use that
as input to the next function. This can clutter up your workspace with lots of
objects. You can also nest functions (i.e. one function inside of another).
This is handy, but can be difficult to read if too many functions are nested as
the process from inside out. The last option, pipes, are a fairly recent
addition to R. Pipes let you take the output of one function and send it
directly to the next, which is useful when you need to do many things to the same
data set.  Pipes in R look like `%>%` and are made available via the `magrittr`
package installed as part of `dplyr`.

```{r, purl = FALSE}
surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight)
```

In the above we use the pipe to send the `surveys` data set first through
`filter`, to keep rows where `weight` was less than 5, and then through `select`
to keep the `species` and `sex` columns. When the data frame is being passed to
the `filter()` and `select()` functions through a pipe, we don't need to include
it as an argument to these functions anymore.

If we wanted to create a new object with this smaller version of the data we
could do so by assigning it a new name:

```{r, purl = FALSE}
surveys_sml <- surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight)

surveys_sml
```

Note that the final data frame is the leftmost part of this expression.

> ### Challenge {.challenge}
>
>  Using pipes, subset the data to include individuals collected before 1995,
>  and retain the columns `year`, `sex`, and `weight.`

<!---
```{r, eval=FALSE, purl=FALSE}
## Answer
surveys %>%
    filter(year < 1995) %>%
    select(year, sex, weight)
```
--->


### Mutate

Frequently you'll want to create new columns based on the values in existing
columns, for example to do unit conversions, or find the ratio of values in two
columns. For this we'll use `mutate()`.

To create a new column of weight in kg:

```{r, purl = FALSE}
surveys %>%
  mutate(weight_kg = weight / 1000)
```

If this runs off your screen and you just want to see the first few rows, you
can use a pipe to view the `head()` of the data (pipes work with non-dplyr
functions too, as long as the `dplyr` or `magrittr` packages are loaded).

```{r, purl = FALSE}
surveys %>%
  mutate(weight_kg = weight / 1000) %>%
  head
```

The first few rows are full of NAs, so if we wanted to remove those we could
insert a `filter()` in this chain:

```{r, purl = FALSE}
surveys %>%
  filter(!is.na(weight)) %>%
  mutate(weight_kg = weight / 1000) %>%
  head
```

`is.na()` is a function that determines whether something is or is not an `NA`.
The `!` symbol negates it, so we're asking for everything that is not an `NA`.

> ### Challenge {.challenge}
>
>  Create a new dataframe from the survey data that meets the following
>  criteria: contains only the `species_id` column and a column that contains
>  values that are half the `hindfoot_length` values (e.g. a new column
>  `hindfoot_half`). In this `hindfoot_half` column, there are no NA values
>  and all values are < 30.
>
>  **Hint**: think about how the commands should be ordered to produce this data frame!

<!---
```{r, eval=FALSE, purl=FALSE}
## Answer
surveys_hindfoot_half <- surveys %>%
    filter(!is.na(hindfoot_length)) %>%
    mutate(hindfoot_half = hindfoot_length / 2) %>%
    filter(hindfoot_half < 30) %>%
    select(species_id, hindfoot_half)
```
--->

### Split-apply-combine data analysis and the summarize() function

Many data analysis tasks can be approached using the "split-apply-combine"
paradigm: split the data into groups, apply some analysis to each group, and
then combine the results. `dplyr` makes this very easy through the use of the
`group_by()` function.


#### The `summarize()` function

`group_by()` is often used together with `summarize()` which collapses each
group into a single-row summary of that group.  `group_by()` takes as argument
the column names that contain the **categorical** variables for which you want
to calculate the summary statistics. So to view mean the `weight` by sex:

```{r, purl = FALSE}
surveys %>%
  group_by(sex) %>%
  summarize(mean_weight = mean(weight, na.rm = TRUE))
```

You can group by multiple columns too:

```{r, purl = FALSE}
surveys %>%
  group_by(sex, species_id) %>%
  summarize(mean_weight = mean(weight, na.rm = TRUE))
```

When grouping both by "sex" and "species_id", the first rows are for individuals
that escaped before their sex could be determined and weighted. You may notice
that the last column does not contain `NA` but `NaN` (which refers to "Not a
Number"). To avoid this, we can remove the missing values for weight before we
attempt to calculate the summary statistics on weight. Because the missing
values are removed, we can omit `na.rm=TRUE` when computing the mean:

```{r, purl = FALSE}
surveys %>%
  filter(!is.na(weight)) %>%
  group_by(sex, species_id) %>%
  summarize(mean_weight = mean(weight))
```

You may also have noticed, that the output from these calls don't run off the
screen anymore. That's because `dplyr` has changed our `data.frame` to a
`tbl_df`. This is a data structure that's very similar to a data frame; for our
purposes the only difference is that it won't automatically show tons of data
going off the screen, while displaying the data type for each column under its
name. If you want to display more data on the screen, you can add the `print()`
function at the end with the argument `n` specifying the number of rows to
display:


```{r, purl = FALSE}
surveys %>%
  filter(!is.na(weight)) %>%
  group_by(sex, species_id) %>%
  summarize(mean_weight = mean(weight)) %>%
  print(n=15)
```

Once the data is grouped, you can also summarize multiple variables at the same
time (and not necessarily on the same variable). For instance, we could add a
column indicating the minimum weight for each species for each sex:

```{r, purl = FALSE}
surveys %>%
  filter(!is.na(weight)) %>%
  group_by(sex, species_id) %>%
  summarize(mean_weight = mean(weight),
            min_weight = min(weight))
```



#### Tallying

When working with data, it is also common to want to know the number of
observations found for each factor or combination of factors. For this, `dplyr`
provides `tally()`. For example, if we wanted to group by sex and find the
number of rows of data for each sex, we would do:

```{r, purl = FALSE}
surveys %>%
  group_by(sex) %>%
  tally()
```

Here, `tally()` is the action applied to the groups created by `group_by()` and
counts the total number of records for each category.

> ### Challenge {.challenge}
>
> How many individuals were caught in each `plot_type` surveyed?

<!---
```{r, echo=FALSE, purl=FALSE}
## Answer
surveys %>%
    group_by(plot_type) %>%
    tally
```
--->

> ### Challenge {.challenge}
>
> Use `group_by()` and `summarize()` to find the mean, min, and max hindfoot
> length for each species (using `species _id`).

<!---
```{r, echo=FALSE, purl=FALSE}
## Answer
surveys %>%
    filter(!is.na(hindfoot_length)) %>%
    group_by(species_id) %>%
    summarize(
        mean_hindfoot_length = mean(hindfoot_length),
        min_hindfoot_length = min(hindfoot_length),
        max_hindfoot_length = max(hindfoot_length)
    )
```
--->

> ### Challenge {.challenge}
>
> What was the heaviest animal measured in each year? Return the columns `year`,
> `genus`, `species_id`, and `weight`.

<!---
## Answer
```{r, echo=FALSE, purl=FALSE}
res <- surveys %>%
    filter(!is.na(weight)) %>%
    group_by(year) %>%
    filter(weight == max(weight)) %>%
    select(year, genus, species, weight) %>%
    arrange(year)
```
--->

# Exporting data

Now that you have learned how to use `dplyr` to extract the information you need
from the raw data, or to summarize your raw data, you may want to export these
new datasets to share them with your collaborators or for archival.

Similarly to the `read.csv()` function used to read in CSV into R, there is a
`write.csv()` function that generates CSV files from data frames.

Before using it, we are going to create a new folder, `data_output` in our
working directory that will store this generated dataset. We don't want to write
generated datasets in the same directory as our raw data. It's good practice to
keep them separate. The `data` folder should only contain the raw, unaltered
data, and should be left alone to make sure we don't delete or modify it; on the
other end the content of `data_output` directory will be generated by our
script, and we know that we can delete the files it contains because we have the
script that can re-generate these files.

In preparation for our next lesson on plotting, we are going to prepare a
cleaned up version of the dataset that doesn't include any missing data.

Let's start by removing observations for which the `species_id` is missing. In
this dataset, the missing species are represented by an empty string and not an
`NA`. Let's also remove observations for which `weight` and the
`hindfoot_length` are missing. This dataset will also only contain observations
of animals for which the sex has been determined:


```{r, purl=FALSE}
surveys_complete <- surveys %>%
  filter(species_id != "",         # remove missing species_id
         !is.na(weight),           # remove missing weight
		 !is.na(hindfoot_length),  # remove missing hindfoot_length
		 sex != "")                # remove missing sex
```

Because we are interested in plotting how species abundances have changed
through time, we are also going to remove observations for rare species (i.e.,
that have been observed less than 50 times). We will do this in two steps: first
we are going to create a dataset that counts how often each species has been
observed, and filter out the rare species; then, we will extract only the
observations for these more common species:

```{r, purl=FALSE}
## Extract the most common species_id
species_counts <- surveys_complete %>%
                  group_by(species_id) %>%
                  tally %>%
				  filter(n >= 50) %>%
				  select(species_id)

## Only keep the most common species
surveys_complete <- surveys_complete %>%
                 filter(species_id %in% species_counts$species_id)
```

To make sure that everyone has the same dataset, check that
`surveys_complete` has `r nrow(surveys_complete)` rows and `r ncol(surveys_complete)`
columns by typing `dim(surveys_complete)`.

Now that our dataset is ready, we can save it as a CSV file in our `data_output`
folder. By default, `write.csv()` includes a column with row names (in our case
the names are just the row numbers), so we need to add `row.names = FALSE` so
they are not included:

```{r, purl=FALSE, eval=FALSE}
write.csv(surveys_complete, file="data_output/surveys_complete.csv",
          row.names=FALSE)
```

```{r, purl=FALSE, eval=TRUE, echo=FALSE}
if (!file.exists("data_output")) dir.create("data_output")
write.csv(surveys_complete, file = "data_output/surveys_complete.csv")
```
